## 中斷與訊號簡介

中斷是改變程式正常執行流程的事件，可以由硬體設備或CPU本身產生。當中斷發生時，現行執行流程會暫停並執行中斷處理程序。中斷處理程序執行完後，先前的執行流程將繼續。導致 CPU 中斷的事件有三類：硬體中斷、軟體中斷與例外狀況。

訊號（signals）本質上是通知程序事件已發生的軟體中斷。這些事件可能是使用者請求或系統問題（如記憶體存取錯誤）的指示。每個訊號都有其訊號編號與預設動作。一個程序可以用以下三種方式回應訊號：

- 採用系統提供的預設方式
- 捕捉訊號，並以程式定義的方式處理
- 完全忽略該訊號

## 訊號種類群組

訊號大致可分為兩類。第一類是傳統或標準訊號，由核心(kernel)用來通知程序事件。在 Linux 中，標準訊號編號為 1 至 31。另一類是即時訊號 (realtime signals)，Linux 同時支援 POSIX 可可靠訊號（下稱「標準訊號」）與 POSIX 即時訊號。

### 即時訊號

POSIX.1b 定義了即時訊號用以彌補標準訊號的若干限制。與標準訊號相比，即時訊號的優點包括：

- 提供更廣泛的訊號範圍，可用於應用程式自訂目的。標準訊號中只有 SIGUSR1 和 SIGUSR2 是可供應用程式使用的兩個。
- 即時訊號可排隊。如果多個相同的即時訊號發送至同一程序，訊號會被多次送達。標準訊號若已在待處理狀態，多餘的訊號只送達一次。
- 發送即時訊號時，可附帶一個整數或指標值資料，接收程序的訊號處理函式能讀取此資料。
- 不同即時訊號的送達順序被保證：待處理的即時訊號中，編號最小的會先被送達。也就是說，訊號有優先權，編號越小優先權越高。相同類型的多個訊號會依發送順序及其附帶資料被送達。

### 標準訊號

標準訊號是Unix初期即存在的經典訊號群。後續章節我們將專注於標準訊號。

## 訊號概述

訊號由某些事件產生。訊號產生後會送達程序，程序會對訊號採取某種行動。在訊號從產生到送達間，訊號處於待處理（pending）狀態。

通常待處理訊號會在程序下次被排程執行時送達，或在程序已在執行時立即送達（如程序自行發送訊號給自己）。有時我們要確保某段程式碼不中斷，這時可把訊號加入程序的訊號遮罩(signal mask)——阻擋送達的訊號集合。當訊號被遮罩時，即使產生也會保留待處理，直到解除遮罩。系統呼叫允許增加與移除訊號遮罩中的訊號。

信號送達時，程序根據訊號執行以下預設動作之一：

- 忽略訊號：核心丟棄訊號，不產生影響。（程序完全不知訊號曾發生）
- 程序終止（被殺死）：被視為非正常終止，相對於调用exit()的正常終止。
- 產生核心轉存(core dump)檔案後終止：核心轉存檔是程序虛擬記憶體映像檔，可用來除錯程序在終止時的狀態。
- 程序暫停執行。
- 程序從暫停狀態復原執行。

程序可自行設定訊號的動作，稱為設定訊號的處置(disposition)。更多處置相關細節，請參考 [此處](https://man7.org/linux/man-pages/man7/signal.7.html)。處置可以是：

- 採用預設動作（用於還原先前改變的處置）
- 忽略訊號（適用於預設行為是終止的訊號）
- 執行訊號處理函式

訊號處理函式由程式設計者撰寫，以在收到訊號時執行適當工作。例如，shell 對 SIGINT 訊號有對應處理，當接收到由中斷字元（Ctrl+C）觸發的 SIGINT 時會停止目前動作，並返回主輸入循環，讓使用者重新看到 shell 提示符。註冊一個訊號處理函式通常稱為安裝(install)或建立(establish)該訊號處理器。訊號送達時，訊號被「處理」或「捕獲」。

請注意，無法將訊號的處置設定為終止或產生核心轉存（除非該訊號的預設就是此行為）。我們只能安裝一個處理函式來呼叫 exit() 或 abort()。abort() 函式會產生 SIGABRT 訊號，使程序產生核心轉存並終止。

## 訊號類型

在 Linux 系統中，可以使用指令 `kill -l` 列出可用訊號。
下表列出訊號編號 1 至 20，完整訊號列表請參考[此處](https://en.wikipedia.org/wiki/Signal_(IPC))。

| 訊號名稱     | 訊號編號    | 預設動作    | 含義    |
| :------------- | :----------: | :-----------: | :-----------: |
|  SIGHUP |  1   | 終止   | 控制終端掛斷或控制程序終止 |
| SIGINT  |  2   | 終止   | 鍵盤中斷 |
| SIGQUIT  |  3   | 產生核心轉存   | 鍵盤退出 |
| SIGILL  |  4   | 產生核心轉存   | 非法指令 |
| SIGTRAP  |  5   | 產生核心轉存   | 偵錯用追蹤/斷點陷阱 |
| SIGABRT , SIGIOT  |  6   | 產生核心轉存   | 非正常終止 |
| SIGBUS  |  7   | 產生核心轉存   | 公車錯誤 |
| SIGFPE  |  8  | 產生核心轉存   | 浮點數例外 |
| SIGKILL  |  9  | 終止  | 強制終止訊號（無法捕捉或忽略） |
| SIGUSR1  |  10  | 終止  | 使用者自訂訊號 1 |
| SIGSEGV  |  11  | 產生核心轉存  | 無效記憶體參考 |
| SIGUSR2  |  12  | 終止  | 使用者自訂訊號 2 |
| SIGPIPE  |  13  | 終止  | 管線破裂；寫入無讀取者管線 |
| SIGALRM  |  14  | 終止  | 時鐘警報訊號 |
| SIGTERM  |  15  | 終止  | 程序終止 |
| SIGSTKFLT | 16 | 終止  | 數學協處理器堆疊錯誤 |
| SIGCHLD | 17 | 忽略 | 子程序停止或終止 |
| SIGCONT | 18 | 繼續 | 若程式被暫停則繼續執行 |
| SIGSTOP | 19 | 停止 | 停止程序（不可捕捉或忽略） |
| SIGTSTP | 20 | 停止 | tty輸入中斷停止 |

## 發送訊號給程序

有三種方式能向程序發送訊號：

- 使用 kill 命令發送訊號

kill 指令可以用來對程序發送訊號。預設會送出 SIGTERM 訊號，但可透過指定訊號編號或名稱，傳送其他訊號。
例如，指令 `kill -9 367` 會對 PID 為 367 的程序送出 SIGKILL。

- 用鍵盤發送訊號

特定鍵盤操作會向執行中程序送出訊號。例如，按下 Ctrl+C 會送出 SIGINT 訊號終止程序。

- 用另一程序透過系統呼叫發送訊號

程序可藉由 kill() 系統呼叫向另一程序發送訊號。此方法可做為同步技術，甚至原始的程序間通訊（IPC）方式。程序也可送訊號給自己。
`int kill(pid_t pid, int sig)` 系統呼叫有兩參數：目標程序 PID 與欲發送的訊號編號。

## 訊號處理

根據上一節訊號表，所有訊號在程式啟動時皆有預設處理程序。調用 signal 函式設定自己的處理程序會覆蓋預設行為。例如加入 SIGINT 處理程序後，按 Ctrl+C 不再終止程式；相反地，將呼叫指定的處理函式以決定程式對 SIGINT 的反應。

以下以 SIGINT 中斷訊號與終止程序為例，採用 Python 的 *signal* 函式庫示範。

按下 Ctrl+C 會送出 SIGINT。在訊號表中，SIGINT 預設動作為終止程序。
示範預設狀況反應：

在 Python 執行以下程式碼：

```
while 1:
        continue
```
按 Ctrl+C。

會看到：

```
^CTraceback (most recent call last):
  File "<stdin>", line 2, in <module>
  KeyboardInterrupt
```

按 Ctrl+C 時，程序收到 SIGINT 並依預設行為終止。

定義 SIGINT 處理函式：

以下程式碼會改寫 SIGINT 預設行為，改為執行一段程式碼。

```
import signal
import sys

#Start of signal_handler function

def signal_handler(signal, frame):
        print ('You pressed Ctrl+C!')

# End of signal_handler function

signal.signal(signal.SIGINT, signal_handler)

```

然後再執行無限迴圈：

```
while 1:
        continue
```

按 Ctrl+C 會看到：

```
^CYou pressed Ctrl+C!
```

訊號不會終止程序，改由自訂函式輸出訊息。若要終止程式，可按 Ctrl+Z 發送 SIGSTOP（預設為暫停程序）。

訊號處理函式定義為 `signal_handler()` ，並接收兩參數：訊號編號及目前堆疊(frame)。`signal.signal()` 用來註冊處理函式，參數為要攔截的訊號及處理函式名稱。

## 訊號在系統呼叫中的角色：以 *wait()* 為例

*wait()* 系統呼叫等候子程序終止，並將子程序終止狀態回傳到所指向的 *statusPtr* 緩衝區。

- 當父程序呼叫 *wait()* 系統呼叫，將暫停父程序執行直到子程序終止。
- 子程序終止時，產生 SIGCHLD 訊號，由核心送達父程序，告知父程序需要收集子程序資訊。
- 父程序收到 SIGCHLD 後，從程序表收割子程序狀態。即使子程序終止，程序表仍有子程序的紀錄（程序條目與PID）。
- 當父程序取得狀態後，此程序表條目刪除，其後子程序紀錄從系統消失。

## 僵屍（Zombie）與孤兒（Orphan）狀態

若父程序不等待子程序終止、不讀取子程序返回的退出狀態，子程序終止後仍會在程序表保留條目，成為僵屍程序。避免長期僵屍需在子程序建立後呼叫 *wait()*。通常會為 SIGCHLD 安裝訊號處理函式，循環呼叫 wait 類函式直到無未處理子程序狀態。

若父程序先於子程序終止，子程序變成孤兒。孤兒子程序會被 init/systemd（PID=1）收養，呼叫取得父 PID 會返回1。
