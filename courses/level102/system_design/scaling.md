在本課程的第一階段中，我們曾看到 AKF 的 [scale cube](https://akfpartners.com/growth-blog/scale-cube) 以及它如何協助服務細分、定義微服務並擴展整體應用程式。我們將使用類似的策略來擴展我們的應用程式，同時使用前一節的估算，從而採用數據驅動的設計，而非任意選擇擴展模式。

## 拆分應用程式

考慮到我們的應用程式可能產生的龐大流量，及其在記憶體和 CPU 資源上的需求，讓我們將應用程式拆分成較小的區塊。最簡單的方式之一是根據端點（endpoints）劃分應用程式，並將其作為獨立實例運行。實際上，這個決策可能會複雜一些，您最終可能會發現多個端點運行在同一實例中。

圖片可以存放在可獨立擴展的 [物件存儲](https://zh.wikipedia.org/wiki/Object_storage) 中，而非放置在應用程式或資料庫所在的伺服器上。這樣可以減少伺服器的資源需求。

## 有狀態 (Stateful) 與無狀態 (Stateless) 服務
<div class="callout callout-primary">
無狀態的進程或服務不依賴於過去調用所儲存的資料；相反，有狀態服務會將其狀態存放在資料存儲中，且通常在每次調用或交易時使用該狀態。在某些情況下，我們可以設計服務，使某些組件成為無狀態，這在多方面都有助益。無狀態的應用程式較容易容器化，而容器化應用程式也更容易擴展。有狀態服務則需要您同時擴展存放狀態的資料存儲。不過，容器化資料庫或擴展資料庫不在本模組範圍內。
</div>

<!--您可參考本模組的容器化章節 [這裡]()-->

如此分配工作負載後，產生的設計可能如圖所示。

![微服務架構圖](images/microservices.jpg)

您可能會注意到圖中有多個資料庫，我們會在接下來的分片（sharding）部分看到更多相關內容。

既然我們已將應用程式拆分為較小的服務，接著需要提升每個端點的容量。著名的柏拉圖法則（Pareto Principle）指出「80% 的結果來自 20% 的原因」，稍作調整，我們可說 80% 的流量會集中在 20% 的圖片上。圖片上傳數和用戶觀看數通常也會有類似偏斜，使用者每日瀏覽圖片的可能性遠高於他們上傳新圖片的頻率。

在我們的簡單設計中，產生包含 5 張圖片的動態消息（feed）頁面，就是從該用戶關注的人所上傳的近期 5 張圖片中挑選。雖然可以在用戶登入時，動態從資料庫擷取圖片並產生頁面，但若大量用戶同時登入並載入消息頁，很快就會讓資料庫負擔過重。有兩個解決方案：快取（caching）以及提前產生用戶的消息頁。

一個擁有百萬粉絲的用戶，可能會引發數十萬次資料庫呼叫，僅為擷取該用戶最新上傳的照片 ID。這會迅速淹沒資料庫，甚至可能導致資料庫當機。

## 分片 (Sharding)

解決資料庫限制的一種方法是擴展資料庫的讀寫能力。分片即為將資料庫寫入分散至多個不同實體的方式，這些資料庫執行於不同的機器上。讀取能力也可以通過我們在本模組第一階段見過的讀取副本來擴展。

與熱門用戶上傳的圖片數相比，觀看次數將是爆炸性增長。在這種情況下，應對用戶上傳的照片 ID 進行快取，而無須頻繁執行昂貴的資料庫查詢請求。

再來考慮應用程式中另一個名為 `/get_user_details` 的端點。它會返回用戶在點擊其他用戶名稱時看到的頁面，該頁面包含該用戶所發布的貼文清單。通常呼叫此端點時，應用程式會與資料庫溝通，抓取該用戶所有貼文清單並回傳結果。若某個人的個人頁面被數千次查看，代表資料庫將承受數千次呼叫，這可能導致熱鍵（hot keys）及熱分區（hot partitions）問題。就像其它系統一樣，負載增加會導致響應時間延遲，進而產生不穩定且可能不佳的用戶體驗。此處簡單解決方案是加一層快取 —— 回傳用戶的個人資料及貼文，而無需每次都呼叫資料庫。

## 快取 (Caching)

快取用來暫時儲存很可能再次被訪問、且常常重複訪問的資料。當被請求的資料存在快取中時，稱為「快取命中（cache hit）」。反之稱為「快取未命中（cache miss）」。合理配置的快取可大幅降低查詢響應時間，並提升系統可擴展性。快取可以設置於使用者與應用程式間的多個層級。在第一階段中，我們已看到如何利用快取/CDN 服務靜態資源，帶來更快的響應時間及降低應用伺服器負載。現在讓我們看看快取在更多場景中的應用。

### 記憶體內快取 (In-memory caching)

記憶體內快取指的是將欲快取的資訊保存在伺服器的主記憶體中，取用速度比硬碟上的資料庫要快得多。我們可以快取任意文本（包含 HTML 片段或 JSON 物件），並快速讀取。記憶體內快取是加入快速快取層的最快方式，且可選擇將其持久化於磁碟。

<div class="callout callout-danger">
快取雖對擴展及效能提升大有幫助，但有些情況下快取會突然失效。例如快取意外被清除，導致所有查詢直接落到資料庫層，且同一資訊的多次呼叫同時涌入。此情況即為「雷擊問題（thundering herd）」，設計系統時需特別留意並考慮防範。
</div>

**快取代理伺服器 (Caching proxies)：**

有些情境下，您可能想要快取整個網頁或上游資源的回應，也希望讓上游告訴你該快取什麼及快取多久。此時使用能理解HTTP快取標頭的快取解決方案會很有效。例如，我們的應用中，若使用者頻繁搜尋特定用戶或關鍵字，快取該回應一段時間，可能比每次重新搜尋更有效率。

讓我們回顧一下其中一個目標 —— 至少 5 萬名獨立訪客同時瀏覽網站並查看其消息頁。藉由快取，我們移除了其中一個可能的瓶頸 —— 資料庫。我們也將單體應用分解為更小的服務。再向目標前進一步，就是水平方向擴展提供消息查看功能的服務，並放置於負載平衡器後。請回想本模組第一階段所討論的擴展概念。

## 快取管理
<div class="callout callout-info">
儘管快取聽起來是解決困難問題的簡單方案，但更困難的是有效管理快取。和系統中其他資源一樣，快取層並非無限大。有效的快取管理意味著要在適當時間移除快取中的資料，以維持高的快取命中率。有許多策略可於特定時間或使用頻率下，失效快取。監控快取命中率並調整快取策略是極為重要的。
</div>

## 參考資料
1. 有許多物件存儲解決方案。[Minio](https://github.com/minio/minio) 是一款自架設方案，雲端供應商也有專屬方案，如 [Azure Blob storage](https://docs.microsoft.com/en-us/azure/storage/blobs/storage-blobs-introduction) 及 [Amazon S3](https://docs.aws.amazon.com/AmazonS3/latest/userguide/Welcome.html)。
2. 微服務架構風格 - [Azure 架構指南](https://docs.microsoft.com/en-us/azure/architecture/guide/architecture-styles/microservices)
3. 有多種記憶體快取方案，較受歡迎的有 [Redis](https://redis.io) 與 [Memcached](https://memcached.org)。雲端廠商亦提供管理式快取服務。
4. 常見快取代理伺服器包括 [Squid](https://www.squid-cache.org) 以及 [Apache Traffic Server](https://trafficserver.apache.org)
5. 雷擊問題 — Instagram 如何 [解決](https://instagram-engineering.com/thundering-herds-promises-82191c8af57d)
